{"version":3,"file":"react-gsap.umd.production.min.js","sources":["../src/types.ts","../src/helper.ts","../src/plugins/PlugInSvgDraw.ts","../src/Provider.tsx","../src/plugins/PlugInCount.ts","../src/Tween.tsx","../src/tools/Reveal.tsx","../src/Timeline.tsx","../src/tools/ScrollTrigger.tsx","../src/tools/SplitText.tsx","../src/tools/Controls.tsx"],"sourcesContent":["export enum PlayState {\n  play = 'play',\n  restart = 'restart',\n  reverse = 'reverse',\n  restartReverse = 'restartReverse',\n  stop = 'stop',\n  stopEnd = 'stopEnd',\n  pause = 'pause',\n  resume = 'resume',\n}\n","import { gsap } from 'gsap';\nimport React from 'react';\nimport { PlayState } from './types';\nimport { TimelineProps } from 'Timeline';\nimport { TweenProps } from 'Tween';\nimport { ContextProps } from 'Provider';\n\nif (!String.prototype.startsWith) {\n  String.prototype.startsWith = function(searchString, position) {\n    position = position || 0;\n    return this.indexOf(searchString, position) === position;\n  };\n}\n\nconst setPlayState = (\n  playState?: PlayState,\n  prevPlayState?: PlayState | null,\n  tween: any = null\n) => {\n  if (tween && playState && playState !== prevPlayState) {\n    if (playState === PlayState.play) {\n      tween.play();\n    } else if (playState === PlayState.restart) {\n      tween.restart(true);\n    } else if (playState === PlayState.reverse) {\n      tween.reverse();\n    } else if (playState === PlayState.restartReverse) {\n      tween.reverse(0);\n    } else if (playState === PlayState.stop) {\n      tween.pause(0);\n    } else if (playState === PlayState.stopEnd) {\n      tween.reverse(0);\n      tween.pause();\n    } else if (playState === PlayState.pause) {\n      tween.pause();\n    } else if (playState === PlayState.resume) {\n      tween.resume();\n    }\n  }\n};\n\nconst setInitialPlayState = (tweenOrTimeline: any, props: TimelineProps | TweenProps) => {\n  const { playState } = props;\n  if (playState) {\n    setPlayState(playState, PlayState.play, tweenOrTimeline);\n  }\n};\n\nconst getInitialPaused = (playState?: PlayState) => {\n  return (\n    playState &&\n    (playState === PlayState.stop ||\n      playState === PlayState.stopEnd ||\n      playState === PlayState.pause)\n  );\n};\n\nconst getTweenFunction = (\n  targets: any,\n  props: TweenProps | TimelineProps,\n  context?: ContextProps\n): gsap.core.Tween | gsap.core.Timeline => {\n  const {\n    children,\n    wrapper,\n\n    duration = 1,\n    from,\n    to,\n\n    stagger,\n\n    progress,\n    totalProgress,\n    playState,\n    disabled,\n    onlyInvalidateTo,\n\n    onCompleteAll,\n    onCompleteAllParams,\n    onCompleteAllScope,\n    onStartAll,\n\n    position,\n    target,\n\n    ...vars\n  } = props;\n\n  let tweenFunction: gsap.core.Tween | gsap.core.Timeline;\n  const paused = getInitialPaused(playState);\n  const plugins = context?.getPlugins(context?.plugins, targets) ?? {};\n\n  if (from && to) {\n    // special props like paused always go in the toVars parameter\n    tweenFunction = gsap.fromTo(targets, from, {\n      stagger,\n      duration,\n      paused,\n      ...to,\n      ...vars,\n      ...plugins,\n    });\n  } else if (to) {\n    tweenFunction = gsap.to(targets, { stagger, duration, paused, ...to, ...vars, ...plugins });\n  } else {\n    tweenFunction = gsap.from(targets, { stagger, duration, paused, ...from, ...vars, ...plugins });\n  }\n\n  // if multiple tweens (stagger), wrap them in a timeline\n  // TODO: if it's already an timeline add event handlers\n  if (Array.isArray(tweenFunction)) {\n    tweenFunction.forEach(t => {\n      t.paused(false);\n    });\n    tweenFunction = gsap.timeline({\n      ...vars,\n      tweens: tweenFunction,\n      smoothChildTiming: true,\n      onComplete: onCompleteAll,\n      onCompleteParams: onCompleteAllParams,\n      onCompleteScope: onCompleteAllScope,\n      onStart: onStartAll,\n    });\n  }\n\n  return tweenFunction;\n};\n\nconst callTweenFunction = (\n  tweenFunction: any,\n  functionName: string,\n  params: Array<any> | undefined = undefined,\n  returnFunction: string | undefined = undefined\n): void => {\n  if (Array.isArray(tweenFunction)) {\n    tweenFunction.forEach(tween => {\n      if (!params && returnFunction) {\n        params = [tween[returnFunction].apply(tween)];\n      }\n      tween[functionName].apply(tween, params);\n    });\n  } else {\n    if (!params && returnFunction) {\n      params = [tweenFunction[returnFunction].apply(tweenFunction)];\n    }\n    tweenFunction[functionName].apply(tweenFunction, params);\n  }\n};\n\nconst isEqual = (obj1: any, obj2: any) => {\n  // very easy equal check\n  // attention: if the order of properties are different it returns false\n  return JSON.stringify(obj1) === JSON.stringify(obj2);\n};\n\nconst refOrInnerRef = (child: any) => {\n  if (child.type.$$typeof && child.type.$$typeof.toString() === 'Symbol(react.forward_ref)') {\n    return 'ref';\n  }\n\n  // styled-components < 4\n  if (child.type.styledComponentId) {\n    return 'innerRef';\n  }\n\n  return 'ref';\n};\n\nfunction isElement(element: any) {\n  return React.isValidElement(element);\n}\n\nfunction isDOMTypeElement(element: any) {\n  return isElement(element) && typeof element.type === 'string';\n}\n\n// https://stackoverflow.com/a/39165137\nfunction getReactNode(dom: any, traverseUp = 0) {\n  const key = Object.keys(dom ?? {}).find(\n    key => key.startsWith('__reactInternalInstance$') || key.startsWith('__reactFiber$')\n  );\n\n  const domFiber = key && dom[key];\n  if (!domFiber) return null;\n\n  // react <16\n  if (domFiber._currentElement) {\n    let compFiber = domFiber._currentElement._owner;\n    for (let i = 0; i < traverseUp; i++) {\n      compFiber = compFiber._currentElement._owner;\n    }\n    return compFiber._instance;\n  }\n\n  // react 16+\n  if (domFiber.stateNode) {\n    return domFiber.stateNode;\n  }\n\n  const getCompFiber = (fiber: any) => {\n    //return fiber._debugOwner; // this also works, but is __DEV__ only\n    let parentFiber = fiber.return;\n    while (typeof parentFiber.type == 'string') {\n      parentFiber = parentFiber.return;\n    }\n    return parentFiber;\n  };\n  let compFiber = getCompFiber(domFiber);\n  for (let i = 0; i < traverseUp; i++) {\n    compFiber = getCompFiber(compFiber);\n  }\n  return compFiber.stateNode;\n}\n\nconst getRefProp = (child: any, addTarget: (target: any) => void) => {\n  // has to be tested if it works, which lib does still use innerRef?\n  if (child.props.innerRef) {\n    return {\n      innerRef: (target: any) => {\n        addTarget(target);\n        const { innerRef } = child.props;\n        if (typeof innerRef === 'function') innerRef(target);\n        else if (innerRef) innerRef.current = target;\n      },\n    };\n  }\n\n  return {\n    ref: (target: any) => {\n      addTarget(target);\n      const { ref } = child;\n      if (typeof ref === 'function') ref(target);\n      else if (ref) ref.current = target;\n    },\n  };\n};\n\nconst setOrAddTarget = (\n  target: any,\n  setTarget: (key: string, target: any) => void,\n  addTarget: (target: any) => void\n) => {\n  const reactNode = getReactNode(target);\n\n  if (reactNode) {\n    addTarget(reactNode);\n  } else if (target) {\n    Object.keys(target).forEach(key => {\n      const elementRef = target[key];\n      if (typeof elementRef === 'object' && elementRef.current) {\n        if (Array.isArray(elementRef.current)) {\n          elementRef.current.forEach((singleRef: React.RefObject<any>) => {\n            setTarget(key, singleRef);\n          });\n        } else {\n          setTarget(key, elementRef.current);\n        }\n      }\n    });\n  }\n};\n\nconst getTargetRefProp = (\n  child: any,\n  setTarget: (key: string, target: any) => void,\n  addTarget: (target: any) => void\n) => {\n  // has to be tested if it works, which lib does still use innerRef?\n  if (child.props.innerRef) {\n    return {\n      innerRef: (target: any) => {\n        setOrAddTarget(target, setTarget, addTarget);\n        // merge refs\n        const { innerRef } = child.props;\n        if (typeof innerRef === 'function') innerRef(target);\n        else if (innerRef) innerRef.current = target;\n      },\n    };\n  }\n\n  return {\n    ref: (target: any) => {\n      setOrAddTarget(target, setTarget, addTarget);\n      // merge refs\n      const { ref } = child;\n      if (typeof ref === 'function') ref(target);\n      else if (ref) ref.current = target;\n    },\n  };\n};\n\nconst nullishCoalescing = <T, R>(value: T, ifNullish: R): T | R => {\n  if (value === null || typeof value === 'undefined') {\n    return ifNullish;\n  }\n  return value;\n};\n\nconst setProps = (\n  tweenOrTimeline: any,\n  props: TimelineProps | TweenProps,\n  prevProps?: TimelineProps | TweenProps\n) => {\n  if (props.progress !== undefined && props.progress !== prevProps?.progress) {\n    tweenOrTimeline.progress(props.progress);\n  }\n  if (props.totalProgress !== undefined && props.totalProgress !== prevProps?.totalProgress) {\n    tweenOrTimeline.totalProgress(props.totalProgress);\n  }\n  if (\n    tweenOrTimeline.duration !== undefined &&\n    props.duration &&\n    props.duration !== prevProps?.duration\n  ) {\n    tweenOrTimeline.duration(props.duration);\n  }\n};\n\nexport {\n  getTweenFunction,\n  callTweenFunction,\n  setPlayState,\n  isEqual,\n  refOrInnerRef,\n  getRefProp,\n  getTargetRefProp,\n  nullishCoalescing,\n  setProps,\n  setInitialPlayState,\n  getInitialPaused,\n};\n","import { nullishCoalescing } from '../helper';\n\nlet gsap: any;\nlet _interpolate: any;\nlet _getProp: any;\nconst _getGSAP = () =>\n  gsap || (typeof window !== 'undefined' && (gsap = window.gsap) && gsap.registerPlugin && gsap);\n\ntype Point = {\n  x: number;\n  y: number;\n};\n\nfunction getDistance(p1: DOMPoint | Point, p2: DOMPoint | Point) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\nfunction getCircleLength(el: SVGCircleElement) {\n  return 2 * Math.PI * parseFloat(nullishCoalescing(el.getAttribute('r'), '1') || '0');\n}\n\nfunction getRectLength(el: SVGRectElement) {\n  return (\n    parseFloat(nullishCoalescing(el.getAttribute('width'), '1') || '0') * 2 +\n    parseFloat(nullishCoalescing(el.getAttribute('height'), '1') || '0') * 2\n  );\n}\n\nfunction getLineLength(el: SVGLineElement) {\n  return getDistance(\n    {\n      x: parseFloat(nullishCoalescing(el.getAttribute('x1'), '1') || '0'),\n      y: parseFloat(nullishCoalescing(el.getAttribute('y1'), '1') || '0'),\n    },\n    {\n      x: parseFloat(nullishCoalescing(el.getAttribute('x2'), '1') || '0'),\n      y: parseFloat(nullishCoalescing(el.getAttribute('y2'), '1') || '0'),\n    }\n  );\n}\n\nfunction getPolylineLength(el: SVGPolylineElement) {\n  const points = el.points;\n  let totalLength = 0;\n  let previousPos: DOMPoint | undefined = undefined;\n  for (let i = 0; i < points.numberOfItems; i++) {\n    const currentPos = points.getItem(i);\n    if (previousPos) totalLength += getDistance(previousPos, currentPos);\n    previousPos = currentPos;\n  }\n  return totalLength;\n}\n\nfunction getPolygonLength(el: SVGPolylineElement) {\n  const points = el.points;\n  return (\n    getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0))\n  );\n}\n\n// if path is splitted into multiple move commands then return longest path\nfunction getPathLength(el: SVGPathElement) {\n  if (!el.hasAttribute('d')) {\n    return el.getTotalLength();\n  }\n  const d = el.getAttribute('d');\n  const pathString = d ? d.replace(/m/gi, 'M') : null;\n\n  if (!pathString) {\n    return el.getTotalLength();\n  }\n\n  const paths = pathString\n    .split('M')\n    .filter(path => path !== '')\n    .map(path => `M${path}`);\n\n  if (paths.length === 1) {\n    return el.getTotalLength();\n  }\n\n  let maxLength = 0;\n\n  paths.forEach(path => {\n    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    pathElement.setAttribute('d', path);\n    maxLength = Math.max(maxLength, pathElement.getTotalLength());\n  });\n\n  return maxLength;\n}\n\nfunction getTotalLength(el: any) {\n  if (el.getTotalLength) {\n    return getPathLength(el);\n  }\n  switch (el.tagName.toLowerCase()) {\n    case 'circle':\n      return getCircleLength(el);\n    case 'rect':\n      return getRectLength(el);\n    case 'line':\n      return getLineLength(el);\n    case 'polyline':\n      return getPolylineLength(el);\n    case 'polygon':\n      return getPolygonLength(el);\n    default:\n      return 0;\n  }\n}\n\nexport const SvgDrawPlugin = {\n  version: '2.0.0',\n  name: 'svgDraw',\n  register(core: any, Plugin: any, propTween: any) {\n    gsap = core;\n    _interpolate = gsap.utils.interpolate;\n    _getProp = gsap.getProperty;\n  },\n  init(target: any, value: number, _tween: any, index: number, targets: any) {\n    const length = getTotalLength(target);\n\n    let lengthParam = value;\n    let offsetParam = 0;\n\n    if (Array.isArray(value)) {\n      lengthParam = value[0];\n      if (value.length >= 2) {\n        offsetParam = value[1] * -1;\n      }\n    }\n\n    let data = this;\n    data.target = target;\n    data.strokeDashoffset = _interpolate(\n      _getProp(target, 'stroke-dashoffset'),\n      length * offsetParam\n    );\n    data.strokeDasharray = _interpolate(_getProp(target, 'stroke-dasharray'), [\n      lengthParam * length,\n      length,\n    ]);\n  },\n  render(progress: number, data: any) {\n    data.target.setAttribute('stroke-dashoffset', data.strokeDashoffset(progress));\n    data.target.setAttribute('stroke-dasharray', data.strokeDasharray(progress));\n  },\n};\n\n_getGSAP() && gsap.registerPlugin(SvgDrawPlugin);\n\nexport { SvgDrawPlugin as default };\n","import React from 'react';\n\ntype RegisteredPlugins = 'scrollTrigger';\ntype Plugin = (targets: any) => any;\ntype Plugins = { [key in RegisteredPlugins]: Plugin } | {};\n\nexport type ContextProps = {\n  registerConsumer: (consumer: any) => void;\n  plugins?: Plugins;\n  getPlugins: (plugins?: Plugins, targets?: any) => any;\n};\n\nexport const Context = React.createContext<ContextProps>({\n  registerConsumer: () => {},\n  getPlugins: () => {},\n  plugins: {},\n});\n\nabstract class Provider<T, S = {}> extends React.Component<T, S> {\n  static contextType = Context;\n\n  consumers: any[];\n  plugins?: Plugins;\n\n  constructor(props: T) {\n    super(props);\n    this.consumers = [];\n    this.plugins = {};\n\n    this.registerConsumer = this.registerConsumer.bind(this);\n    this.getContextValue = this.getContextValue.bind(this);\n    this.getPlugin = this.getPlugin.bind(this);\n    this.getPlugins = this.getPlugins.bind(this);\n    this.renderWithProvider = this.renderWithProvider.bind(this);\n  }\n\n  registerConsumer(consumer: any) {\n    this.consumers.push(consumer);\n  }\n\n  getContextValue(plugin: Plugins = {}) {\n    return {\n      registerConsumer: this.registerConsumer,\n      // plugins: { ...this.context.plugins, ...plugin },\n      plugins: plugin,\n      getPlugins: this.getPlugins,\n    };\n  }\n\n  getPlugin(props: any, targets: any) {\n    return {};\n  }\n\n  getPlugins(plugins?: Plugins, targets?: any) {\n    return Object.keys(plugins ?? {}).reduce((acc, plugin) => {\n      if (Object.prototype.hasOwnProperty.call(plugins, plugin)) {\n        // @ts-ignore\n        return { ...acc, [plugin]: this.getPlugin(plugins[plugin], targets) };\n      }\n      return acc;\n    }, {});\n  }\n\n  renderWithProvider(output: any, plugin?: Plugins) {\n    return <Context.Provider value={this.getContextValue(plugin)}>{output}</Context.Provider>;\n  }\n}\n\nexport default Provider;\n","import { nullishCoalescing } from '../helper';\n\nlet gsap: any;\nlet _interpolate: any;\nlet _format: any;\nconst _getGSAP = () =>\n  gsap || (typeof window !== 'undefined' && (gsap = window.gsap) && gsap.registerPlugin && gsap);\n\ntype Prop =\n  | {\n      value: string | number;\n      format: () => (value: string | number) => number | string;\n    }\n  | number\n  | string;\n\nexport const CountPlugin = {\n  version: '1.0.0',\n  name: 'count',\n  register(core: any, Plugin: any, propTween: any) {\n    gsap = core;\n    _interpolate = gsap.utils.interpolate;\n    _format = (value: string | number) => parseInt(value.toString(), 10);\n  },\n  init(target: any, value: Prop, _tween: any, index: number, targets: any) {\n    let inputValue = value;\n    let format = _format;\n    if (typeof value === 'object') {\n      inputValue = nullishCoalescing(value.value, 0);\n      if (value.format) {\n        format = value.format;\n      }\n    }\n\n    const initialCount = parseFloat(target.innerText);\n\n    let data = this;\n    data.target = target;\n    data.count = _interpolate(initialCount, parseFloat(inputValue.toString()));\n    data.format = format;\n  },\n  render(progress: number, data: any) {\n    data.target.innerText = data.format(data.count(progress));\n  },\n};\n\n_getGSAP() && gsap.registerPlugin(CountPlugin);\n\nexport { CountPlugin as default };\n","import React, { Fragment, ReactElement } from 'react';\nimport { gsap } from 'gsap';\nimport { PlayState } from './types';\nimport {\n  getTweenFunction,\n  setPlayState,\n  isEqual,\n  getRefProp,\n  setProps,\n  setInitialPlayState,\n} from './helper';\nimport { Context } from './Provider';\n\nimport SvgDrawPlugin from './plugins/PlugInSvgDraw';\nimport CountPlugin from './plugins/PlugInCount';\n\n// @ts-ignore\ngsap.registerPlugin(SvgDrawPlugin);\n\n// @ts-ignore\ngsap.registerPlugin(CountPlugin);\n\ntype StaggerFunction = (index: number, target: any, list: any) => number;\ntype StaggerFromValues = 'start' | 'center' | 'edges' | 'random' | 'end';\ntype EaseFunction = (value: number) => number;\n\nexport type Stagger =\n  | {\n      amount?: number;\n      each?: number;\n      from?: StaggerFromValues | number | [number, number];\n      grid?: [number, number] | 'auto';\n      axis?: 'x' | 'y';\n      ease?: string | EaseFunction;\n      repeat?: number;\n      yoyo?: boolean;\n      [prop: string]: any;\n    }\n  | number\n  | StaggerFunction;\n\nexport type TweenProps = {\n  /** One or multiple \"refable\" components  */\n  children?: React.ReactNode;\n  wrapper?: React.ReactElement;\n  target?: number | string;\n  position?: string | number;\n\n  from?: any;\n  to?: any;\n  stagger?: Stagger;\n\n  duration?: number;\n  progress?: number;\n  totalProgress?: number;\n  playState?: PlayState;\n\n  disabled?: boolean;\n  onlyInvalidateTo?: boolean;\n\n  [prop: string]: any;\n};\n\nclass Tween extends React.Component<TweenProps, {}> {\n  static displayName = 'Tween';\n  static contextType = Context;\n\n  tween: any;\n  targets: any[] = [];\n\n  constructor(props: TweenProps) {\n    super(props);\n\n    this.addTarget = this.addTarget.bind(this);\n  }\n\n  componentDidMount() {\n    this.createTween();\n\n    // props at mount\n    setProps(this.tween, this.props);\n    setInitialPlayState(this.tween, this.props);\n\n    this.context.registerConsumer(this);\n  }\n\n  componentWillUnmount() {\n    if (this.tween) {\n      this.tween.kill();\n    }\n  }\n\n  getSnapshotBeforeUpdate() {\n    this.targets = [];\n    return null;\n  }\n\n  componentDidUpdate(prevProps: TweenProps) {\n    const {\n      children,\n      wrapper,\n\n      duration,\n      from,\n      to,\n      stagger,\n\n      progress,\n      totalProgress,\n      playState,\n      disabled,\n      onlyInvalidateTo,\n\n      onCompleteAll,\n      onCompleteAllParams,\n      onCompleteAllScope,\n      onStartAll,\n\n      position,\n      target,\n\n      ...vars\n    } = this.props;\n\n    // if children change create a new tween\n    // TODO: replace easy length check with fast equal check\n    if (React.Children.count(prevProps.children) !== React.Children.count(children)) {\n      this.createTween();\n    }\n\n    if (disabled) {\n      return;\n    }\n\n    // execute function calls\n    setProps(this.tween, this.props, prevProps);\n\n    // if \"to\" props are changed: reinit and restart tween\n    if (!isEqual(to, prevProps.to)) {\n      // is Tween\n      if (!this.tween.getChildren) {\n        this.tween.vars = { ...to, ...vars };\n\n        if (onlyInvalidateTo) {\n          var progressTmp = this.tween.progress();\n          this.tween\n            .progress(0)\n            .invalidate()\n            .progress(progressTmp);\n        } else {\n          this.tween.invalidate();\n        }\n      }\n      // is Timeline\n      // TODO: not yet ready\n      else {\n        let delay = 0;\n        this.tween.getChildren(false, true, false).forEach((tween: any) => {\n          tween.vars = { ...to, ...vars, ...{ delay } };\n          tween.invalidate();\n          // delay += stagger || 0;\n        });\n      }\n\n      if (!this.tween.paused()) {\n        this.tween.restart();\n      }\n    }\n\n    setPlayState(playState, prevProps.playState, this.tween);\n  }\n\n  createTween() {\n    if (this.tween) {\n      this.tween.kill();\n    }\n\n    if (this.props.children) {\n      this.tween = getTweenFunction(this.targets, this.props, this.context);\n    } else {\n      // why this is needed?\n      this.tween = () => {};\n    }\n  }\n\n  getGSAP() {\n    return this.tween;\n  }\n\n  setGSAP(tween: any) {\n    this.tween = tween;\n  }\n\n  addTarget(target: any) {\n    // target is null at unmount\n    if (target !== null) {\n      this.targets.push(target);\n    }\n  }\n\n  getTargets() {\n    return this.targets;\n  }\n\n  render() {\n    let { children, wrapper } = this.props;\n\n    const output = (\n      <Fragment>\n        {React.Children.map(children, child => {\n          return React.cloneElement(child as ReactElement, getRefProp(child, this.addTarget));\n        })}\n      </Fragment>\n    );\n\n    if (wrapper) {\n      return React.cloneElement(wrapper, [], output);\n    }\n\n    return output;\n  }\n}\n\nexport default Tween;\n","import React from 'react';\nimport { gsap } from 'gsap';\nimport { nullishCoalescing } from '../helper';\nimport Provider from '../Provider';\n\nexport type RevealProps = {\n  children: React.ReactNode;\n  trigger: React.ReactElement | null;\n  repeat: boolean;\n  root: Element | null;\n  rootMargin: string;\n  threshold: number;\n};\n\nenum EntryState {\n  unknown,\n  entered,\n  exited,\n}\n\nclass Reveal extends Provider<RevealProps> {\n  static displayName = 'Reveal';\n\n  static defaultProps = {\n    trigger: null,\n    repeat: false,\n    root: null,\n    rootMargin: '0px',\n    threshold: 0.66,\n  };\n\n  timeline: any;\n  triggerRef: HTMLElement | null = null;\n  observer: IntersectionObserver | null = null;\n\n  init() {\n    this.createTimeline();\n    this.createIntersectionObserver();\n  }\n\n  kill() {\n    this.killTimeline();\n    this.killIntersectionObserver();\n  }\n\n  componentDidMount() {\n    this.init();\n  }\n\n  componentWillUnmount() {\n    this.kill();\n  }\n\n  componentDidUpdate(prevProps: RevealProps) {\n    const { children, trigger } = this.props;\n\n    // if children change create a new timeline\n    // TODO: replace easy length check with fast equal check\n    // TODO: same for props.target?\n    if (React.Children.count(prevProps.children) !== React.Children.count(children)) {\n      this.init();\n    }\n\n    if (prevProps.trigger !== trigger) {\n      this.init();\n    }\n  }\n\n  createTimeline() {\n    this.killTimeline();\n\n    // init timeline\n    this.timeline = gsap.timeline({\n      smoothChildTiming: true,\n      paused: true,\n    });\n\n    // add consumers\n    this.consumers.forEach(consumer => {\n      const { position } = consumer.props;\n      this.timeline.add(consumer.getGSAP().play(), nullishCoalescing(position, 0));\n    });\n  }\n\n  killTimeline() {\n    if (this.timeline) {\n      this.timeline.kill();\n    }\n  }\n\n  createIntersectionObserver() {\n    let { root, rootMargin, threshold } = this.props;\n\n    const options = {\n      root,\n      rootMargin,\n      threshold: [0, threshold],\n    };\n\n    this.observer = new IntersectionObserver(this.intersectionObserverCallback, options);\n\n    // It would be better if we wouldn't need an extra wrapper.\n    // But it can be problematic for example with a fadeInLeft animation\n    // were the element is out of the viewport in the initial state.\n    // In this case there wouldn't be an intersection..\n    if (!this.triggerRef) {\n      this.consumers.forEach(consumer => {\n        consumer.getTargets().forEach((target: any) => {\n          this.observer && this.observer.observe(target);\n        });\n      });\n    } else {\n      this.observer && this.observer.observe(this.triggerRef);\n    }\n  }\n\n  killIntersectionObserver() {\n    this.unobserveAll();\n    this.observer = null;\n  }\n\n  unobserveAll() {\n    if (this.observer) {\n      if (!this.triggerRef) {\n        this.consumers.forEach(consumer => {\n          consumer.getTargets().forEach((target: any) => {\n            this.observer && this.observer.unobserve(target);\n          });\n        });\n      } else {\n        this.observer && this.observer.unobserve(this.triggerRef);\n      }\n    }\n  }\n\n  intersectionObserverCallback = (entries: any) => {\n    let { repeat, threshold } = this.props;\n    let state: EntryState = EntryState.unknown;\n\n    for (const entry of entries) {\n      if (entry.isIntersecting && entry.intersectionRatio >= threshold) {\n        this.timeline.play();\n        state = EntryState.entered;\n        break;\n      } else if (!entry.isIntersecting) {\n        state = EntryState.exited;\n        break;\n      }\n    }\n\n    if (!repeat && state === EntryState.entered) {\n      this.killIntersectionObserver();\n    } else if (repeat && state === EntryState.exited) {\n      this.timeline.pause(0);\n    }\n  };\n\n  getGSAP() {\n    return this.timeline;\n  }\n\n  render() {\n    let { children, trigger } = this.props;\n\n    let output = trigger ? (\n      <trigger.type {...trigger.props} ref={(trigger: HTMLElement) => (this.triggerRef = trigger)}>\n        {children}\n      </trigger.type>\n    ) : (\n      children\n    );\n\n    return this.renderWithProvider(output);\n  }\n}\n\nexport default Reveal;\n","import React, { Fragment, ReactElement, ReactNode } from 'react';\nimport { gsap } from 'gsap';\nimport { isForwardRef, isFragment } from 'react-is';\nimport { PlayState } from './types';\nimport {\n  getInitialPaused,\n  getTargetRefProp,\n  getTweenFunction,\n  nullishCoalescing,\n  setInitialPlayState,\n  setPlayState,\n  setProps,\n} from './helper';\nimport Provider, { Context } from './Provider';\nimport { TweenProps } from './Tween';\n\ntype Label = {\n  label: string;\n  position: string | number;\n};\n\nexport type Targets = Map<string | number, ReactElement | ReactElement[]>;\nexport type TargetsRef = {\n  set: (key: string, target: any) => void;\n};\n\nexport type Target = ReactElement | null;\n\nexport type TimelineProps = {\n  children: ReactNode;\n  wrapper?: ReactElement;\n  target?: Target;\n  position?: string | number;\n  labels?: Label[];\n\n  duration?: number;\n  progress?: number;\n  totalProgress?: number;\n  playState?: PlayState;\n\n  [prop: string]: any;\n};\n\nclass Timeline extends Provider<TimelineProps> {\n  static displayName = 'Timeline';\n\n  timeline: any;\n  targets: Targets = new Map();\n\n  static defaultProps = {\n    playState: PlayState.play,\n  };\n\n  constructor(props: TimelineProps) {\n    super(props);\n\n    this.addTarget = this.addTarget.bind(this);\n    this.setTarget = this.setTarget.bind(this);\n  }\n\n  componentDidMount() {\n    this.createTimeline();\n\n    // props at mount\n    setProps(this.timeline, this.props);\n    setInitialPlayState(this.timeline, this.props);\n\n    this.context.registerConsumer(this);\n  }\n\n  componentWillUnmount() {\n    this.timeline.kill();\n  }\n\n  getSnapshotBeforeUpdate() {\n    this.targets = new Map();\n    return null;\n  }\n\n  componentDidUpdate(prevProps: TimelineProps) {\n    const { children, duration, progress, totalProgress, playState, target } = this.props;\n\n    // if children change create a new timeline\n    // TODO: replace easy length check with fast equal check\n    // TODO: same for props.target?\n    if (React.Children.count(prevProps.children) !== React.Children.count(children)) {\n      this.createTimeline();\n    }\n\n    // execute function calls\n    setProps(this.timeline, this.props, prevProps);\n\n    // TODO: need rerender or something if target change?\n    // if (target !== prevProps.target) {\n    //   this.forceUpdate();\n    // }\n\n    setPlayState(playState, prevProps.playState, this.timeline);\n  }\n\n  createTimeline() {\n    const {\n      children,\n      target,\n      duration,\n      progress,\n      totalProgress,\n      playState,\n      labels,\n      position,\n      ...vars\n    } = this.props;\n\n    if (this.timeline) {\n      this.timeline.kill();\n    }\n\n    const plugins = this.context?.getPlugins(this.context?.plugins, this.targets) ?? {};\n\n    // init timeline\n    this.timeline = gsap.timeline({\n      smoothChildTiming: true,\n      paused: getInitialPaused(playState),\n      ...vars,\n      ...plugins,\n    });\n\n    if (labels) {\n      labels.forEach(label => {\n        this.timeline.addLabel(label.label, label.position);\n      });\n    }\n\n    // add tweens or nested timelines to timeline\n    this.consumers.forEach(consumer => {\n      // Tween with no children -> control Timeline target\n      if (consumer.tween && !consumer.props.children) {\n        const { position, target, stagger, ...vars } = consumer.props as TweenProps;\n\n        // get target if not nullish\n        let targets = null;\n        if (target !== null && typeof target !== 'undefined') {\n          targets = this.targets.get(target);\n        }\n\n        // if no target found -> take all Timeline targets as target\n        const tween = getTweenFunction(\n          // @ts-ignore\n          nullishCoalescing(targets, Array.from(this.targets.values())),\n          {\n            stagger,\n            ...vars,\n          }\n        );\n        this.timeline.add(tween, nullishCoalescing(position, '+=0'));\n        consumer.setGSAP(tween);\n      } else {\n        const { position } = consumer.props;\n        this.timeline.add(consumer.getGSAP(), nullishCoalescing(position, '+=0'));\n      }\n    });\n  }\n\n  getGSAP() {\n    return this.timeline;\n  }\n\n  addTarget(target: any) {\n    if (target !== null) {\n      this.targets.set(this.targets.size, target);\n    }\n  }\n\n  setTarget(key: string, target: any) {\n    if (target !== null) {\n      if (this.targets.has(key)) {\n        const targets = this.targets.get(key);\n        if (Array.isArray(targets)) {\n          this.targets.set(key, [...targets, target]);\n        } else {\n          this.targets.set(key, [targets, target]);\n        }\n      } else {\n        this.targets.set(key, target);\n      }\n    }\n  }\n\n  setTargets(targets: Targets) {\n    this.targets = targets;\n  }\n\n  getTargets() {\n    return this.targets;\n  }\n\n  cloneElement(child: any) {\n    // @ts-ignore\n    return React.cloneElement(child, getTargetRefProp(child, this.setTarget, this.addTarget));\n  }\n\n  renderTarget(target?: Target): ReactNode {\n    if (!target) {\n      return null;\n    }\n\n    // if is forwardRef clone and pass targets as ref\n    if (isForwardRef(target)) {\n      return this.cloneElement(target);\n    }\n\n    // else iterate the first level of children and set targets\n    return (\n      <Fragment>\n        {/* First render the target */}\n        {React.Children.map<ReactElement, ReactElement>(target, child => {\n          if (isFragment(child)) {\n            return React.Children.map(child.props.children, fragmentChild => {\n              return this.cloneElement(fragmentChild);\n            });\n          }\n          return this.cloneElement(child);\n        })}\n      </Fragment>\n    );\n  }\n\n  render() {\n    let { target, children, wrapper } = this.props;\n\n    const renderedTarget = this.renderTarget(target);\n\n    let output = (\n      <Fragment>\n        {renderedTarget}\n        {children}\n      </Fragment>\n    );\n\n    if (wrapper) {\n      output = React.cloneElement(wrapper, [], output);\n    }\n\n    return this.renderWithProvider(output);\n  }\n}\n\nexport default Timeline;\n","import React from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger as ScrollTriggerPlugin } from 'gsap/dist/ScrollTrigger';\nimport Provider, { Context } from '../Provider';\n\ngsap.registerPlugin(ScrollTriggerPlugin);\n\nexport type ScrollTriggerProps = {\n  children?: React.ReactNode;\n} & gsap.plugins.ScrollTriggerInstanceVars;\n\nclass ScrollTrigger extends Provider<ScrollTriggerProps> {\n  static displayName = 'ScrollTrigger';\n  static contextType = Context;\n\n  scrollTrigger: any | null = null;\n  targets: any = {};\n\n  constructor(props: ScrollTriggerProps) {\n    super(props);\n\n    this.getPlugin = this.getPlugin.bind(this);\n  }\n\n  // override and pass registerConsumer to next parent provider\n  registerConsumer(consumer: any) {\n    this.context.registerConsumer(consumer);\n  }\n\n  componentDidMount() {\n    const { children, ...scrollTrigger } = this.props;\n\n    if (!children) {\n      this.scrollTrigger = ScrollTriggerPlugin.create(scrollTrigger);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.scrollTrigger) {\n      this.scrollTrigger.kill();\n    }\n  }\n\n  // componentDidUpdate(prevProps: ScrollTriggerProps) {\n  //   const { trigger } = this.props;\n  //\n  //   if (trigger !== prevProps.trigger) {\n  //     console.log('prevProps.trigger', prevProps.trigger);\n  //     console.log('trigger', trigger);\n  //   }\n  // }\n\n  getGSAP() {\n    return this.scrollTrigger;\n  }\n\n  getPlugin(props: any, targets: any) {\n    let { children, trigger: triggerProp, ...scrollTrigger } = props;\n\n    let trigger = triggerProp;\n\n    if (targets instanceof Map) {\n      if (trigger) {\n        const target = targets.get(trigger);\n        if (target) {\n          trigger = target;\n        }\n      } else {\n        trigger = Array.from(targets.values());\n      }\n    } else if (!trigger) {\n      trigger = targets;\n    }\n\n    return {\n      trigger,\n      ...scrollTrigger,\n    };\n  }\n\n  render() {\n    const { children, ...scrollTrigger } = this.props;\n    if (!children) {\n      return null;\n    }\n    return this.renderWithProvider(children, {\n      scrollTrigger,\n    });\n  }\n}\n\nexport default ScrollTrigger;\n","import React from 'react';\n\ntype SplitWordsProps = {\n  children: React.ReactNode;\n  wrapper: React.ReactElement;\n  delimiter?: string;\n};\n\ntype SplitCharsProps = {\n  children: React.ReactNode;\n  wrapper: React.ReactElement;\n};\n\nconst escapeRegExp = (regExp: string) => {\n  var specialChars = ['$', '^', '*', '(', ')', '+', '[', ']', '{', '}', '\\\\', '|', '.', '?', '/'];\n  var regex = new RegExp('(\\\\' + specialChars.join('|\\\\') + ')', 'g');\n  return regExp.replace(regex, '\\\\$1');\n};\n\n// TODO: possible or better to output all the refs as one array?\nexport const SplitWords = React.forwardRef<any, SplitWordsProps>(\n  ({ children, wrapper, delimiter = ' ' }, ref) => {\n    if (typeof children !== 'string') {\n      throw new Error('SplitWords only accepts a string as child.');\n    }\n    const words = children.split(new RegExp(`(${escapeRegExp(delimiter)})`, 'g'));\n    return (\n      <>\n        {words.map((word: string, i: number) => {\n          if (delimiter === ' ' && word === delimiter) {\n            return <React.Fragment key={i}> </React.Fragment>;\n          }\n          return React.cloneElement(wrapper, { ref, key: i }, word);\n        })}\n      </>\n    );\n  }\n);\n\n// TODO: possible or better to output all the refs as one array?\nexport const SplitChars = React.forwardRef<any, SplitCharsProps>(({ children, wrapper }, ref) => {\n  if (typeof children !== 'string') {\n    throw new Error('SplitChars only accepts a string as child.');\n  }\n  return (\n    <>\n      {children\n        .split(\n          /(?=(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))/\n        )\n        .map((char: string, i: number) => {\n          // TODO: enhance check for space\n          if (char === ' ') {\n            return <React.Fragment key={i}> </React.Fragment>;\n          }\n          return React.cloneElement(wrapper, { ref, key: i }, char);\n        })}\n    </>\n  );\n});\n\nexport const SplitLetters = React.forwardRef((props: any, ref) => {\n  console.warn('Deprecation warning: Use SplitChars instead of SplitLetters');\n  return <SplitChars {...props} ref={ref} />;\n});\n","import React from 'react';\nimport { PlayState } from './../types';\nimport { setPlayState } from './../helper';\nimport Provider from '../Provider';\n\ntype ControlsProps = {\n  playState?: PlayState;\n};\n\ntype ControlsState = {\n  totalProgress: number;\n  playState?: PlayState;\n  prevPlayState?: PlayState;\n};\n\nclass Controls extends Provider<ControlsProps, ControlsState> {\n  gsap: any;\n  slider: any;\n  sliderTouched: boolean = false;\n\n  state = {\n    totalProgress: 0,\n    playState: undefined,\n    prevPlayState: undefined,\n  };\n\n  containerStyle = {\n    backgroundColor: '#f0f0f0',\n    padding: '10px 10px 0 10px',\n    marginTop: '10px',\n    position: 'relative' as 'relative',\n    zIndex: 2,\n    fontFamily: 'verdana, sans-serif',\n    fontSize: '16px',\n    border: '1px solid #ccc',\n  };\n\n  buttonContainerStyle = {\n    margin: '0',\n    display: 'flex',\n    flexWrap: 'wrap' as 'wrap',\n    justifyContent: 'space-between',\n  };\n\n  buttonStyle = {\n    border: '1px solid #999',\n    backgroundColor: '#f0f0f0',\n    padding: '5px',\n    margin: '10px 10px 10px 0',\n    cursor: 'pointer',\n  };\n\n  sliderStyle = {\n    margin: '0',\n    width: '100%',\n  };\n\n  playStateStyle = {\n    color: '#999',\n    margin: '10px 0',\n    fontSize: '14px',\n  };\n\n  componentDidMount() {\n    if (this.consumers.length) {\n      this.gsap = this.consumers[0];\n\n      const gsap = this.gsap.getGSAP();\n\n      if (gsap) {\n        gsap.eventCallback('onUpdate', this.onUpdate);\n\n        if (this.props.playState) {\n          this.setPlayState(this.props.playState);\n        } else {\n          // get child initial state\n          if (gsap.paused()) {\n            this.setPlayState(PlayState.pause);\n          } else if (gsap.reversed()) {\n            this.setPlayState(PlayState.reverse);\n          } else {\n            this.setPlayState(PlayState.play);\n          }\n        }\n\n        const totalProgress = gsap.totalProgress();\n        this.slider.value = totalProgress * 100;\n      }\n    }\n  }\n\n  componentDidUpdate() {\n    this.onUpdate();\n  }\n\n  onUpdate = () => {\n    if (this.gsap && this.slider && !this.sliderTouched) {\n      const totalProgress = this.gsap.getGSAP().totalProgress();\n      this.slider.value = totalProgress * 100;\n    }\n  };\n\n  onChange = (event: any) => {\n    if (this.gsap && this.gsap.getGSAP()) {\n      this.gsap.getGSAP().totalProgress(event.target.value / 100);\n    }\n  };\n\n  setPlayState = (state: PlayState) => {\n    this.setState(prevState => {\n      return {\n        playState: state,\n        prevPlayState: prevState.playState,\n      };\n    });\n  };\n\n  getControls = (_totalProgress: any, playState: PlayState | undefined) => (\n    <div style={this.containerStyle}>\n      <input\n        ref={el => (this.slider = el)}\n        type=\"range\"\n        style={this.sliderStyle}\n        step=\"0.001\"\n        onChange={e => this.onChange(e)}\n        onMouseDown={() => (this.sliderTouched = true)}\n        onMouseUp={() => (this.sliderTouched = false)}\n      />\n      <div style={this.buttonContainerStyle}>\n        <div>\n          <button\n            type=\"button\"\n            style={this.buttonStyle}\n            onClick={() => this.setPlayState(PlayState.play)}\n          >\n            Play\n          </button>\n          <button\n            type=\"button\"\n            style={this.buttonStyle}\n            onClick={() => this.setPlayState(PlayState.reverse)}\n          >\n            Reverse\n          </button>\n          <button\n            type=\"button\"\n            style={this.buttonStyle}\n            onClick={() => this.setPlayState(PlayState.pause)}\n          >\n            Pause\n          </button>\n          <button\n            type=\"button\"\n            style={this.buttonStyle}\n            onClick={() => this.setPlayState(PlayState.stop)}\n          >\n            Stop\n          </button>\n        </div>\n        <span style={this.playStateStyle}>{playState}</span>\n      </div>\n    </div>\n  );\n\n  render() {\n    const { children } = this.props;\n    const { totalProgress, playState, prevPlayState } = this.state;\n\n    if (this.gsap) {\n      setPlayState(playState, prevPlayState, this.gsap.getGSAP());\n    }\n\n    return this.renderWithProvider(\n      <div>\n        {children}\n        {this.getControls(totalProgress, playState)}\n      </div>\n    );\n  }\n}\n\nexport default Controls;\n"],"names":["PlayState","String","prototype","startsWith","searchString","position","this","indexOf","gsap","_interpolate","_getProp","setPlayState","playState","prevPlayState","tween","play","restart","reverse","restartReverse","stop","pause","stopEnd","resume","setInitialPlayState","tweenOrTimeline","props","getInitialPaused","getTweenFunction","targets","context","tweenFunction","duration","from","to","stagger","progress","disabled","onCompleteAll","onCompleteAllParams","onCompleteAllScope","onStartAll","paused","plugins","getPlugins","fromTo","vars","Array","isArray","forEach","t","timeline","tweens","smoothChildTiming","onComplete","onCompleteParams","onCompleteScope","onStart","setOrAddTarget","target","setTarget","addTarget","reactNode","dom","traverseUp","key","Object","keys","find","domFiber","_currentElement","compFiber","_owner","i","_instance","stateNode","getCompFiber","fiber","parentFiber","type","getReactNode","elementRef","current","singleRef","nullishCoalescing","value","ifNullish","setProps","prevProps","undefined","totalProgress","Context","React","createContext","registerConsumer","Provider","consumers","_this","bind","getContextValue","getPlugin","renderWithProvider","consumer","push","plugin","reduce","acc","hasOwnProperty","call","_this2","output","Component","getDistance","p1","p2","Math","sqrt","pow","x","y","getPolylineLength","el","points","totalLength","previousPos","numberOfItems","currentPos","getItem","_format","SvgDrawPlugin","version","name","register","core","Plugin","propTween","utils","interpolate","getProperty","init","_tween","index","length","getTotalLength","hasAttribute","d","getAttribute","pathString","replace","paths","split","filter","path","map","maxLength","pathElement","document","createElementNS","setAttribute","max","getPathLength","tagName","toLowerCase","PI","parseFloat","getCircleLength","getRectLength","getLineLength","getPolygonLength","lengthParam","offsetParam","strokeDashoffset","strokeDasharray","render","data","window","registerPlugin","CountPlugin","parseInt","toString","inputValue","format","initialCount","innerText","count","Tween","componentDidMount","createTween","componentWillUnmount","kill","getSnapshotBeforeUpdate","componentDidUpdate","children","wrapper","onlyInvalidateTo","Children","obj2","JSON","stringify","getChildren","delay","invalidate","progressTmp","getGSAP","setGSAP","getTargets","Fragment","child","cloneElement","innerRef","ref","getRefProp","EntryState","Timeline","Map","createTimeline","labels","_this$context","_this$context2","label","addLabel","get","values","add","set","size","has","setTargets","getTargetRefProp","renderTarget","isForwardRef","isFragment","fragmentChild","_this3","renderedTarget","Reveal","entries","repeat","threshold","state","unknown","entry","isIntersecting","intersectionRatio","entered","exited","killIntersectionObserver","createIntersectionObserver","killTimeline","trigger","observer","IntersectionObserver","intersectionObserverCallback","root","rootMargin","triggerRef","observe","unobserveAll","unobserve","_this4","_this5","ScrollTriggerPlugin","ScrollTrigger","scrollTrigger","create","triggerProp","SplitWords","forwardRef","delimiter","Error","regExp","regex","words","RegExp","join","word","SplitChars","char","SplitLetters","console","warn","backgroundColor","padding","marginTop","zIndex","fontFamily","fontSize","border","margin","display","flexWrap","justifyContent","cursor","width","color","slider","sliderTouched","event","setState","prevState","_totalProgress","style","containerStyle","sliderStyle","step","onChange","e","onMouseDown","onMouseUp","buttonContainerStyle","buttonStyle","onClick","playStateStyle","eventCallback","onUpdate","reversed","getControls"],"mappings":"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"}