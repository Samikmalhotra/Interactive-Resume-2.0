'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var gsap$2 = require('gsap');
var reactIs = require('react-is');
var ScrollTrigger$1 = require('gsap/dist/ScrollTrigger');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

(function (PlayState) {
  PlayState["play"] = "play";
  PlayState["restart"] = "restart";
  PlayState["reverse"] = "reverse";
  PlayState["restartReverse"] = "restartReverse";
  PlayState["stop"] = "stop";
  PlayState["stopEnd"] = "stopEnd";
  PlayState["pause"] = "pause";
  PlayState["resume"] = "resume";
})(exports.PlayState || (exports.PlayState = {}));

if (!String.prototype.startsWith) {
  String.prototype.startsWith = function (searchString, position) {
    position = position || 0;
    return this.indexOf(searchString, position) === position;
  };
}

var setPlayState = function setPlayState(playState, prevPlayState, tween) {
  if (tween === void 0) {
    tween = null;
  }

  if (tween && playState && playState !== prevPlayState) {
    if (playState === exports.PlayState.play) {
      tween.play();
    } else if (playState === exports.PlayState.restart) {
      tween.restart(true);
    } else if (playState === exports.PlayState.reverse) {
      tween.reverse();
    } else if (playState === exports.PlayState.restartReverse) {
      tween.reverse(0);
    } else if (playState === exports.PlayState.stop) {
      tween.pause(0);
    } else if (playState === exports.PlayState.stopEnd) {
      tween.reverse(0);
      tween.pause();
    } else if (playState === exports.PlayState.pause) {
      tween.pause();
    } else if (playState === exports.PlayState.resume) {
      tween.resume();
    }
  }
};

var setInitialPlayState = function setInitialPlayState(tweenOrTimeline, props) {
  var playState = props.playState;

  if (playState) {
    setPlayState(playState, exports.PlayState.play, tweenOrTimeline);
  }
};

var getInitialPaused = function getInitialPaused(playState) {
  return playState && (playState === exports.PlayState.stop || playState === exports.PlayState.stopEnd || playState === exports.PlayState.pause);
};

var getTweenFunction = function getTweenFunction(targets, props, context) {
  var _context$getPlugins;

  var _props$duration = props.duration,
      duration = _props$duration === void 0 ? 1 : _props$duration,
      from = props.from,
      to = props.to,
      stagger = props.stagger,
      playState = props.playState,
      onCompleteAll = props.onCompleteAll,
      onCompleteAllParams = props.onCompleteAllParams,
      onCompleteAllScope = props.onCompleteAllScope,
      onStartAll = props.onStartAll,
      vars = _objectWithoutPropertiesLoose(props, ["children", "wrapper", "duration", "from", "to", "stagger", "progress", "totalProgress", "playState", "disabled", "onlyInvalidateTo", "onCompleteAll", "onCompleteAllParams", "onCompleteAllScope", "onStartAll", "position", "target"]);

  var tweenFunction;
  var paused = getInitialPaused(playState);
  var plugins = (_context$getPlugins = context === null || context === void 0 ? void 0 : context.getPlugins(context === null || context === void 0 ? void 0 : context.plugins, targets)) !== null && _context$getPlugins !== void 0 ? _context$getPlugins : {};

  if (from && to) {
    // special props like paused always go in the toVars parameter
    tweenFunction = gsap$2.gsap.fromTo(targets, from, _extends({
      stagger: stagger,
      duration: duration,
      paused: paused
    }, to, vars, plugins));
  } else if (to) {
    tweenFunction = gsap$2.gsap.to(targets, _extends({
      stagger: stagger,
      duration: duration,
      paused: paused
    }, to, vars, plugins));
  } else {
    tweenFunction = gsap$2.gsap.from(targets, _extends({
      stagger: stagger,
      duration: duration,
      paused: paused
    }, from, vars, plugins));
  } // if multiple tweens (stagger), wrap them in a timeline
  // TODO: if it's already an timeline add event handlers


  if (Array.isArray(tweenFunction)) {
    tweenFunction.forEach(function (t) {
      t.paused(false);
    });
    tweenFunction = gsap$2.gsap.timeline(_extends({}, vars, {
      tweens: tweenFunction,
      smoothChildTiming: true,
      onComplete: onCompleteAll,
      onCompleteParams: onCompleteAllParams,
      onCompleteScope: onCompleteAllScope,
      onStart: onStartAll
    }));
  }

  return tweenFunction;
};

var isEqual = function isEqual(obj1, obj2) {
  // very easy equal check
  // attention: if the order of properties are different it returns false
  return JSON.stringify(obj1) === JSON.stringify(obj2);
};


function getReactNode(dom, traverseUp) {
  if (traverseUp === void 0) {
    traverseUp = 0;
  }

  var key = Object.keys(dom !== null && dom !== void 0 ? dom : {}).find(function (key) {
    return key.startsWith('__reactInternalInstance$') || key.startsWith('__reactFiber$');
  });
  var domFiber = key && dom[key];
  if (!domFiber) return null; // react <16

  if (domFiber._currentElement) {
    var _compFiber = domFiber._currentElement._owner;

    for (var i = 0; i < traverseUp; i++) {
      _compFiber = _compFiber._currentElement._owner;
    }

    return _compFiber._instance;
  } // react 16+


  if (domFiber.stateNode) {
    return domFiber.stateNode;
  }

  var getCompFiber = function getCompFiber(fiber) {
    //return fiber._debugOwner; // this also works, but is __DEV__ only
    var parentFiber = fiber["return"];

    while (typeof parentFiber.type == 'string') {
      parentFiber = parentFiber["return"];
    }

    return parentFiber;
  };

  var compFiber = getCompFiber(domFiber);

  for (var _i = 0; _i < traverseUp; _i++) {
    compFiber = getCompFiber(compFiber);
  }

  return compFiber.stateNode;
}

var getRefProp = function getRefProp(child, addTarget) {
  // has to be tested if it works, which lib does still use innerRef?
  if (child.props.innerRef) {
    return {
      innerRef: function innerRef(target) {
        addTarget(target);
        var innerRef = child.props.innerRef;
        if (typeof innerRef === 'function') innerRef(target);else if (innerRef) innerRef.current = target;
      }
    };
  }

  return {
    ref: function ref(target) {
      addTarget(target);
      var ref = child.ref;
      if (typeof ref === 'function') ref(target);else if (ref) ref.current = target;
    }
  };
};

var setOrAddTarget = function setOrAddTarget(target, setTarget, addTarget) {
  var reactNode = getReactNode(target);

  if (reactNode) {
    addTarget(reactNode);
  } else if (target) {
    Object.keys(target).forEach(function (key) {
      var elementRef = target[key];

      if (typeof elementRef === 'object' && elementRef.current) {
        if (Array.isArray(elementRef.current)) {
          elementRef.current.forEach(function (singleRef) {
            setTarget(key, singleRef);
          });
        } else {
          setTarget(key, elementRef.current);
        }
      }
    });
  }
};

var getTargetRefProp = function getTargetRefProp(child, setTarget, addTarget) {
  // has to be tested if it works, which lib does still use innerRef?
  if (child.props.innerRef) {
    return {
      innerRef: function innerRef(target) {
        setOrAddTarget(target, setTarget, addTarget); // merge refs

        var innerRef = child.props.innerRef;
        if (typeof innerRef === 'function') innerRef(target);else if (innerRef) innerRef.current = target;
      }
    };
  }

  return {
    ref: function ref(target) {
      setOrAddTarget(target, setTarget, addTarget); // merge refs

      var ref = child.ref;
      if (typeof ref === 'function') ref(target);else if (ref) ref.current = target;
    }
  };
};

var nullishCoalescing = function nullishCoalescing(value, ifNullish) {
  if (value === null || typeof value === 'undefined') {
    return ifNullish;
  }

  return value;
};

var setProps = function setProps(tweenOrTimeline, props, prevProps) {
  if (props.progress !== undefined && props.progress !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.progress)) {
    tweenOrTimeline.progress(props.progress);
  }

  if (props.totalProgress !== undefined && props.totalProgress !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.totalProgress)) {
    tweenOrTimeline.totalProgress(props.totalProgress);
  }

  if (tweenOrTimeline.duration !== undefined && props.duration && props.duration !== (prevProps === null || prevProps === void 0 ? void 0 : prevProps.duration)) {
    tweenOrTimeline.duration(props.duration);
  }
};

var Context = /*#__PURE__*/React__default.createContext({
  registerConsumer: function registerConsumer() {},
  getPlugins: function getPlugins() {},
  plugins: {}
});

var Provider = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Provider, _React$Component);

  function Provider(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.consumers = [];
    _this.plugins = {};
    _this.registerConsumer = _this.registerConsumer.bind(_assertThisInitialized(_this));
    _this.getContextValue = _this.getContextValue.bind(_assertThisInitialized(_this));
    _this.getPlugin = _this.getPlugin.bind(_assertThisInitialized(_this));
    _this.getPlugins = _this.getPlugins.bind(_assertThisInitialized(_this));
    _this.renderWithProvider = _this.renderWithProvider.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Provider.prototype;

  _proto.registerConsumer = function registerConsumer(consumer) {
    this.consumers.push(consumer);
  };

  _proto.getContextValue = function getContextValue(plugin) {
    if (plugin === void 0) {
      plugin = {};
    }

    return {
      registerConsumer: this.registerConsumer,
      // plugins: { ...this.context.plugins, ...plugin },
      plugins: plugin,
      getPlugins: this.getPlugins
    };
  };

  _proto.getPlugin = function getPlugin(props, targets) {
    return {};
  };

  _proto.getPlugins = function getPlugins(plugins, targets) {
    var _this2 = this;

    return Object.keys(plugins !== null && plugins !== void 0 ? plugins : {}).reduce(function (acc, plugin) {
      if (Object.prototype.hasOwnProperty.call(plugins, plugin)) {
        var _extends2;

        // @ts-ignore
        return _extends({}, acc, (_extends2 = {}, _extends2[plugin] = _this2.getPlugin(plugins[plugin], targets), _extends2));
      }

      return acc;
    }, {});
  };

  _proto.renderWithProvider = function renderWithProvider(output, plugin) {
    return React__default.createElement(Context.Provider, {
      value: this.getContextValue(plugin)
    }, output);
  };

  return Provider;
}(React__default.Component);

Provider.contextType = Context;

var gsap;

var _interpolate;

var _getProp;

var _getGSAP = function _getGSAP() {
  return gsap || typeof window !== 'undefined' && (gsap = window.gsap) && gsap.registerPlugin && gsap;
};

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return 2 * Math.PI * parseFloat(nullishCoalescing(el.getAttribute('r'), '1') || '0');
}

function getRectLength(el) {
  return parseFloat(nullishCoalescing(el.getAttribute('width'), '1') || '0') * 2 + parseFloat(nullishCoalescing(el.getAttribute('height'), '1') || '0') * 2;
}

function getLineLength(el) {
  return getDistance({
    x: parseFloat(nullishCoalescing(el.getAttribute('x1'), '1') || '0'),
    y: parseFloat(nullishCoalescing(el.getAttribute('y1'), '1') || '0')
  }, {
    x: parseFloat(nullishCoalescing(el.getAttribute('x2'), '1') || '0'),
    y: parseFloat(nullishCoalescing(el.getAttribute('y2'), '1') || '0')
  });
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos = undefined;

  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (previousPos) totalLength += getDistance(previousPos, currentPos);
    previousPos = currentPos;
  }

  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
} // if path is splitted into multiple move commands then return longest path


function getPathLength(el) {
  if (!el.hasAttribute('d')) {
    return el.getTotalLength();
  }

  var d = el.getAttribute('d');
  var pathString = d ? d.replace(/m/gi, 'M') : null;

  if (!pathString) {
    return el.getTotalLength();
  }

  var paths = pathString.split('M').filter(function (path) {
    return path !== '';
  }).map(function (path) {
    return "M" + path;
  });

  if (paths.length === 1) {
    return el.getTotalLength();
  }

  var maxLength = 0;
  paths.forEach(function (path) {
    var pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathElement.setAttribute('d', path);
    maxLength = Math.max(maxLength, pathElement.getTotalLength());
  });
  return maxLength;
}

function getTotalLength(el) {
  if (el.getTotalLength) {
    return getPathLength(el);
  }

  switch (el.tagName.toLowerCase()) {
    case 'circle':
      return getCircleLength(el);

    case 'rect':
      return getRectLength(el);

    case 'line':
      return getLineLength(el);

    case 'polyline':
      return getPolylineLength(el);

    case 'polygon':
      return getPolygonLength(el);

    default:
      return 0;
  }
}

var SvgDrawPlugin = {
  version: '2.0.0',
  name: 'svgDraw',
  register: function register(core, Plugin, propTween) {
    gsap = core;
    _interpolate = gsap.utils.interpolate;
    _getProp = gsap.getProperty;
  },
  init: function init(target, value, _tween, index, targets) {
    var length = getTotalLength(target);
    var lengthParam = value;
    var offsetParam = 0;

    if (Array.isArray(value)) {
      lengthParam = value[0];

      if (value.length >= 2) {
        offsetParam = value[1] * -1;
      }
    }

    var data = this;
    data.target = target;
    data.strokeDashoffset = _interpolate(_getProp(target, 'stroke-dashoffset'), length * offsetParam);
    data.strokeDasharray = _interpolate(_getProp(target, 'stroke-dasharray'), [lengthParam * length, length]);
  },
  render: function render(progress, data) {
    data.target.setAttribute('stroke-dashoffset', data.strokeDashoffset(progress));
    data.target.setAttribute('stroke-dasharray', data.strokeDasharray(progress));
  }
};
_getGSAP() && gsap.registerPlugin(SvgDrawPlugin);

var gsap$1;

var _interpolate$1;

var _format;

var _getGSAP$1 = function _getGSAP() {
  return gsap$1 || typeof window !== 'undefined' && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
};

var CountPlugin = {
  version: '1.0.0',
  name: 'count',
  register: function register(core, Plugin, propTween) {
    gsap$1 = core;
    _interpolate$1 = gsap$1.utils.interpolate;

    _format = function _format(value) {
      return parseInt(value.toString(), 10);
    };
  },
  init: function init(target, value, _tween, index, targets) {
    var inputValue = value;
    var format = _format;

    if (typeof value === 'object') {
      inputValue = nullishCoalescing(value.value, 0);

      if (value.format) {
        format = value.format;
      }
    }

    var initialCount = parseFloat(target.innerText);
    var data = this;
    data.target = target;
    data.count = _interpolate$1(initialCount, parseFloat(inputValue.toString()));
    data.format = format;
  },
  render: function render(progress, data) {
    data.target.innerText = data.format(data.count(progress));
  }
};
_getGSAP$1() && gsap$1.registerPlugin(CountPlugin);

gsap$2.gsap.registerPlugin(SvgDrawPlugin); // @ts-ignore

gsap$2.gsap.registerPlugin(CountPlugin);

var Tween = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Tween, _React$Component);

  function Tween(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.targets = [];
    _this.addTarget = _this.addTarget.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Tween.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.createTween(); // props at mount

    setProps(this.tween, this.props);
    setInitialPlayState(this.tween, this.props);
    this.context.registerConsumer(this);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.tween) {
      this.tween.kill();
    }
  };

  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {
    this.targets = [];
    return null;
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props = this.props,
        children = _this$props.children,
        to = _this$props.to,
        playState = _this$props.playState,
        disabled = _this$props.disabled,
        onlyInvalidateTo = _this$props.onlyInvalidateTo,
        vars = _objectWithoutPropertiesLoose(_this$props, ["children", "wrapper", "duration", "from", "to", "stagger", "progress", "totalProgress", "playState", "disabled", "onlyInvalidateTo", "onCompleteAll", "onCompleteAllParams", "onCompleteAllScope", "onStartAll", "position", "target"]); // if children change create a new tween
    // TODO: replace easy length check with fast equal check


    if (React__default.Children.count(prevProps.children) !== React__default.Children.count(children)) {
      this.createTween();
    }

    if (disabled) {
      return;
    } // execute function calls


    setProps(this.tween, this.props, prevProps); // if "to" props are changed: reinit and restart tween

    if (!isEqual(to, prevProps.to)) {
      // is Tween
      if (!this.tween.getChildren) {
        this.tween.vars = _extends({}, to, vars);

        if (onlyInvalidateTo) {
          var progressTmp = this.tween.progress();
          this.tween.progress(0).invalidate().progress(progressTmp);
        } else {
          this.tween.invalidate();
        }
      } // is Timeline
      // TODO: not yet ready
      else {
          var delay = 0;
          this.tween.getChildren(false, true, false).forEach(function (tween) {
            tween.vars = _extends({}, to, vars, {
              delay: delay
            });
            tween.invalidate(); // delay += stagger || 0;
          });
        }

      if (!this.tween.paused()) {
        this.tween.restart();
      }
    }

    setPlayState(playState, prevProps.playState, this.tween);
  };

  _proto.createTween = function createTween() {
    if (this.tween) {
      this.tween.kill();
    }

    if (this.props.children) {
      this.tween = getTweenFunction(this.targets, this.props, this.context);
    } else {
      // why this is needed?
      this.tween = function () {};
    }
  };

  _proto.getGSAP = function getGSAP() {
    return this.tween;
  };

  _proto.setGSAP = function setGSAP(tween) {
    this.tween = tween;
  };

  _proto.addTarget = function addTarget(target) {
    // target is null at unmount
    if (target !== null) {
      this.targets.push(target);
    }
  };

  _proto.getTargets = function getTargets() {
    return this.targets;
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        children = _this$props2.children,
        wrapper = _this$props2.wrapper;
    var output = React__default.createElement(React.Fragment, null, React__default.Children.map(children, function (child) {
      return React__default.cloneElement(child, getRefProp(child, _this2.addTarget));
    }));

    if (wrapper) {
      return React__default.cloneElement(wrapper, [], output);
    }

    return output;
  };

  return Tween;
}(React__default.Component);

Tween.displayName = 'Tween';
Tween.contextType = Context;

var Timeline = /*#__PURE__*/function (_Provider) {
  _inheritsLoose(Timeline, _Provider);

  function Timeline(props) {
    var _this;

    _this = _Provider.call(this, props) || this;
    _this.targets = new Map();
    _this.addTarget = _this.addTarget.bind(_assertThisInitialized(_this));
    _this.setTarget = _this.setTarget.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Timeline.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.createTimeline(); // props at mount

    setProps(this.timeline, this.props);
    setInitialPlayState(this.timeline, this.props);
    this.context.registerConsumer(this);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.timeline.kill();
  };

  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {
    this.targets = new Map();
    return null;
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props = this.props,
        children = _this$props.children,
        playState = _this$props.playState;
 // if children change create a new timeline
    // TODO: replace easy length check with fast equal check
    // TODO: same for props.target?

    if (React__default.Children.count(prevProps.children) !== React__default.Children.count(children)) {
      this.createTimeline();
    } // execute function calls


    setProps(this.timeline, this.props, prevProps); // TODO: need rerender or something if target change?
    // if (target !== prevProps.target) {
    //   this.forceUpdate();
    // }

    setPlayState(playState, prevProps.playState, this.timeline);
  };

  _proto.createTimeline = function createTimeline() {
    var _this$context$getPlug,
        _this$context,
        _this$context2,
        _this2 = this;

    var _this$props2 = this.props,
        playState = _this$props2.playState,
        labels = _this$props2.labels,
        vars = _objectWithoutPropertiesLoose(_this$props2, ["children", "target", "duration", "progress", "totalProgress", "playState", "labels", "position"]);

    if (this.timeline) {
      this.timeline.kill();
    }

    var plugins = (_this$context$getPlug = (_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.getPlugins((_this$context2 = this.context) === null || _this$context2 === void 0 ? void 0 : _this$context2.plugins, this.targets)) !== null && _this$context$getPlug !== void 0 ? _this$context$getPlug : {}; // init timeline

    this.timeline = gsap$2.gsap.timeline(_extends({
      smoothChildTiming: true,
      paused: getInitialPaused(playState)
    }, vars, plugins));

    if (labels) {
      labels.forEach(function (label) {
        _this2.timeline.addLabel(label.label, label.position);
      });
    } // add tweens or nested timelines to timeline


    this.consumers.forEach(function (consumer) {
      // Tween with no children -> control Timeline target
      if (consumer.tween && !consumer.props.children) {
        var _consumer$props = consumer.props,
            _position = _consumer$props.position,
            _target = _consumer$props.target,
            stagger = _consumer$props.stagger,
            _vars = _objectWithoutPropertiesLoose(_consumer$props, ["position", "target", "stagger"]); // get target if not nullish


        var targets = null;

        if (_target !== null && typeof _target !== 'undefined') {
          targets = _this2.targets.get(_target);
        } // if no target found -> take all Timeline targets as target


        var tween = getTweenFunction( // @ts-ignore
        nullishCoalescing(targets, Array.from(_this2.targets.values())), _extends({
          stagger: stagger
        }, _vars));

        _this2.timeline.add(tween, nullishCoalescing(_position, '+=0'));

        consumer.setGSAP(tween);
      } else {
        var _position2 = consumer.props.position;

        _this2.timeline.add(consumer.getGSAP(), nullishCoalescing(_position2, '+=0'));
      }
    });
  };

  _proto.getGSAP = function getGSAP() {
    return this.timeline;
  };

  _proto.addTarget = function addTarget(target) {
    if (target !== null) {
      this.targets.set(this.targets.size, target);
    }
  };

  _proto.setTarget = function setTarget(key, target) {
    if (target !== null) {
      if (this.targets.has(key)) {
        var targets = this.targets.get(key);

        if (Array.isArray(targets)) {
          this.targets.set(key, [].concat(targets, [target]));
        } else {
          this.targets.set(key, [targets, target]);
        }
      } else {
        this.targets.set(key, target);
      }
    }
  };

  _proto.setTargets = function setTargets(targets) {
    this.targets = targets;
  };

  _proto.getTargets = function getTargets() {
    return this.targets;
  };

  _proto.cloneElement = function cloneElement(child) {
    // @ts-ignore
    return React__default.cloneElement(child, getTargetRefProp(child, this.setTarget, this.addTarget));
  };

  _proto.renderTarget = function renderTarget(target) {
    var _this3 = this;

    if (!target) {
      return null;
    } // if is forwardRef clone and pass targets as ref


    if (reactIs.isForwardRef(target)) {
      return this.cloneElement(target);
    } // else iterate the first level of children and set targets


    return React__default.createElement(React.Fragment, null, React__default.Children.map(target, function (child) {
      if (reactIs.isFragment(child)) {
        return React__default.Children.map(child.props.children, function (fragmentChild) {
          return _this3.cloneElement(fragmentChild);
        });
      }

      return _this3.cloneElement(child);
    }));
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        target = _this$props3.target,
        children = _this$props3.children,
        wrapper = _this$props3.wrapper;
    var renderedTarget = this.renderTarget(target);
    var output = React__default.createElement(React.Fragment, null, renderedTarget, children);

    if (wrapper) {
      output = React__default.cloneElement(wrapper, [], output);
    }

    return this.renderWithProvider(output);
  };

  return Timeline;
}(Provider);

Timeline.displayName = 'Timeline';
Timeline.defaultProps = {
  playState: exports.PlayState.play
};

var EntryState;

(function (EntryState) {
  EntryState[EntryState["unknown"] = 0] = "unknown";
  EntryState[EntryState["entered"] = 1] = "entered";
  EntryState[EntryState["exited"] = 2] = "exited";
})(EntryState || (EntryState = {}));

var Reveal = /*#__PURE__*/function (_Provider) {
  _inheritsLoose(Reveal, _Provider);

  function Reveal() {
    var _this;

    _this = _Provider.apply(this, arguments) || this;
    _this.triggerRef = null;
    _this.observer = null;

    _this.intersectionObserverCallback = function (entries) {
      var _this$props = _this.props,
          repeat = _this$props.repeat,
          threshold = _this$props.threshold;
      var state = EntryState.unknown;

      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
        var entry = _step.value;

        if (entry.isIntersecting && entry.intersectionRatio >= threshold) {
          _this.timeline.play();

          state = EntryState.entered;
          break;
        } else if (!entry.isIntersecting) {
          state = EntryState.exited;
          break;
        }
      }

      if (!repeat && state === EntryState.entered) {
        _this.killIntersectionObserver();
      } else if (repeat && state === EntryState.exited) {
        _this.timeline.pause(0);
      }
    };

    return _this;
  }

  var _proto = Reveal.prototype;

  _proto.init = function init() {
    this.createTimeline();
    this.createIntersectionObserver();
  };

  _proto.kill = function kill() {
    this.killTimeline();
    this.killIntersectionObserver();
  };

  _proto.componentDidMount = function componentDidMount() {
    this.init();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.kill();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props2 = this.props,
        children = _this$props2.children,
        trigger = _this$props2.trigger; // if children change create a new timeline
    // TODO: replace easy length check with fast equal check
    // TODO: same for props.target?

    if (React__default.Children.count(prevProps.children) !== React__default.Children.count(children)) {
      this.init();
    }

    if (prevProps.trigger !== trigger) {
      this.init();
    }
  };

  _proto.createTimeline = function createTimeline() {
    var _this2 = this;

    this.killTimeline(); // init timeline

    this.timeline = gsap$2.gsap.timeline({
      smoothChildTiming: true,
      paused: true
    }); // add consumers

    this.consumers.forEach(function (consumer) {
      var position = consumer.props.position;

      _this2.timeline.add(consumer.getGSAP().play(), nullishCoalescing(position, 0));
    });
  };

  _proto.killTimeline = function killTimeline() {
    if (this.timeline) {
      this.timeline.kill();
    }
  };

  _proto.createIntersectionObserver = function createIntersectionObserver() {
    var _this3 = this;

    var _this$props3 = this.props,
        root = _this$props3.root,
        rootMargin = _this$props3.rootMargin,
        threshold = _this$props3.threshold;
    var options = {
      root: root,
      rootMargin: rootMargin,
      threshold: [0, threshold]
    };
    this.observer = new IntersectionObserver(this.intersectionObserverCallback, options); // It would be better if we wouldn't need an extra wrapper.
    // But it can be problematic for example with a fadeInLeft animation
    // were the element is out of the viewport in the initial state.
    // In this case there wouldn't be an intersection..

    if (!this.triggerRef) {
      this.consumers.forEach(function (consumer) {
        consumer.getTargets().forEach(function (target) {
          _this3.observer && _this3.observer.observe(target);
        });
      });
    } else {
      this.observer && this.observer.observe(this.triggerRef);
    }
  };

  _proto.killIntersectionObserver = function killIntersectionObserver() {
    this.unobserveAll();
    this.observer = null;
  };

  _proto.unobserveAll = function unobserveAll() {
    var _this4 = this;

    if (this.observer) {
      if (!this.triggerRef) {
        this.consumers.forEach(function (consumer) {
          consumer.getTargets().forEach(function (target) {
            _this4.observer && _this4.observer.unobserve(target);
          });
        });
      } else {
        this.observer && this.observer.unobserve(this.triggerRef);
      }
    }
  };

  _proto.getGSAP = function getGSAP() {
    return this.timeline;
  };

  _proto.render = function render() {
    var _this5 = this;

    var _this$props4 = this.props,
        children = _this$props4.children,
        trigger = _this$props4.trigger;
    var output = trigger ? React__default.createElement(trigger.type, Object.assign({}, trigger.props, {
      ref: function ref(trigger) {
        return _this5.triggerRef = trigger;
      }
    }), children) : children;
    return this.renderWithProvider(output);
  };

  return Reveal;
}(Provider);

Reveal.displayName = 'Reveal';
Reveal.defaultProps = {
  trigger: null,
  repeat: false,
  root: null,
  rootMargin: '0px',
  threshold: 0.66
};

gsap$2.gsap.registerPlugin(ScrollTrigger$1.ScrollTrigger);

var ScrollTrigger = /*#__PURE__*/function (_Provider) {
  _inheritsLoose(ScrollTrigger, _Provider);

  function ScrollTrigger(props) {
    var _this;

    _this = _Provider.call(this, props) || this;
    _this.scrollTrigger = null;
    _this.targets = {};
    _this.getPlugin = _this.getPlugin.bind(_assertThisInitialized(_this));
    return _this;
  } // override and pass registerConsumer to next parent provider


  var _proto = ScrollTrigger.prototype;

  _proto.registerConsumer = function registerConsumer(consumer) {
    this.context.registerConsumer(consumer);
  };

  _proto.componentDidMount = function componentDidMount() {
    var _this$props = this.props,
        children = _this$props.children,
        scrollTrigger = _objectWithoutPropertiesLoose(_this$props, ["children"]);

    if (!children) {
      this.scrollTrigger = ScrollTrigger$1.ScrollTrigger.create(scrollTrigger);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.scrollTrigger) {
      this.scrollTrigger.kill();
    }
  } // componentDidUpdate(prevProps: ScrollTriggerProps) {
  //   const { trigger } = this.props;
  //
  //   if (trigger !== prevProps.trigger) {
  //     console.log('prevProps.trigger', prevProps.trigger);
  //     console.log('trigger', trigger);
  //   }
  // }
  ;

  _proto.getGSAP = function getGSAP() {
    return this.scrollTrigger;
  };

  _proto.getPlugin = function getPlugin(props, targets) {
    var triggerProp = props.trigger,
        scrollTrigger = _objectWithoutPropertiesLoose(props, ["children", "trigger"]);

    var trigger = triggerProp;

    if (targets instanceof Map) {
      if (trigger) {
        var target = targets.get(trigger);

        if (target) {
          trigger = target;
        }
      } else {
        trigger = Array.from(targets.values());
      }
    } else if (!trigger) {
      trigger = targets;
    }

    return _extends({
      trigger: trigger
    }, scrollTrigger);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        children = _this$props2.children,
        scrollTrigger = _objectWithoutPropertiesLoose(_this$props2, ["children"]);

    if (!children) {
      return null;
    }

    return this.renderWithProvider(children, {
      scrollTrigger: scrollTrigger
    });
  };

  return ScrollTrigger;
}(Provider);

ScrollTrigger.displayName = 'ScrollTrigger';
ScrollTrigger.contextType = Context;

var escapeRegExp = function escapeRegExp(regExp) {
  var specialChars = ['$', '^', '*', '(', ')', '+', '[', ']', '{', '}', '\\', '|', '.', '?', '/'];
  var regex = new RegExp('(\\' + specialChars.join('|\\') + ')', 'g');
  return regExp.replace(regex, '\\$1');
}; // TODO: possible or better to output all the refs as one array?


var SplitWords = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      wrapper = _ref.wrapper,
      _ref$delimiter = _ref.delimiter,
      delimiter = _ref$delimiter === void 0 ? ' ' : _ref$delimiter;

  if (typeof children !== 'string') {
    throw new Error('SplitWords only accepts a string as child.');
  }

  var words = children.split(new RegExp("(" + escapeRegExp(delimiter) + ")", 'g'));
  return React__default.createElement(React__default.Fragment, null, words.map(function (word, i) {
    if (delimiter === ' ' && word === delimiter) {
      return React__default.createElement(React__default.Fragment, {
        key: i
      }, " ");
    }

    return React__default.cloneElement(wrapper, {
      ref: ref,
      key: i
    }, word);
  }));
}); // TODO: possible or better to output all the refs as one array?

var SplitChars = /*#__PURE__*/React__default.forwardRef(function (_ref2, ref) {
  var children = _ref2.children,
      wrapper = _ref2.wrapper;

  if (typeof children !== 'string') {
    throw new Error('SplitChars only accepts a string as child.');
  }

  return React__default.createElement(React__default.Fragment, null, children.split(/(?=(?:[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))/).map(function (_char, i) {
    // TODO: enhance check for space
    if (_char === ' ') {
      return React__default.createElement(React__default.Fragment, {
        key: i
      }, " ");
    }

    return React__default.cloneElement(wrapper, {
      ref: ref,
      key: i
    }, _char);
  }));
});
var SplitLetters = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  console.warn('Deprecation warning: Use SplitChars instead of SplitLetters');
  return React__default.createElement(SplitChars, Object.assign({}, props, {
    ref: ref
  }));
});

var Controls = /*#__PURE__*/function (_Provider) {
  _inheritsLoose(Controls, _Provider);

  function Controls() {
    var _this;

    _this = _Provider.apply(this, arguments) || this;
    _this.sliderTouched = false;
    _this.state = {
      totalProgress: 0,
      playState: undefined,
      prevPlayState: undefined
    };
    _this.containerStyle = {
      backgroundColor: '#f0f0f0',
      padding: '10px 10px 0 10px',
      marginTop: '10px',
      position: 'relative',
      zIndex: 2,
      fontFamily: 'verdana, sans-serif',
      fontSize: '16px',
      border: '1px solid #ccc'
    };
    _this.buttonContainerStyle = {
      margin: '0',
      display: 'flex',
      flexWrap: 'wrap',
      justifyContent: 'space-between'
    };
    _this.buttonStyle = {
      border: '1px solid #999',
      backgroundColor: '#f0f0f0',
      padding: '5px',
      margin: '10px 10px 10px 0',
      cursor: 'pointer'
    };
    _this.sliderStyle = {
      margin: '0',
      width: '100%'
    };
    _this.playStateStyle = {
      color: '#999',
      margin: '10px 0',
      fontSize: '14px'
    };

    _this.onUpdate = function () {
      if (_this.gsap && _this.slider && !_this.sliderTouched) {
        var totalProgress = _this.gsap.getGSAP().totalProgress();

        _this.slider.value = totalProgress * 100;
      }
    };

    _this.onChange = function (event) {
      if (_this.gsap && _this.gsap.getGSAP()) {
        _this.gsap.getGSAP().totalProgress(event.target.value / 100);
      }
    };

    _this.setPlayState = function (state) {
      _this.setState(function (prevState) {
        return {
          playState: state,
          prevPlayState: prevState.playState
        };
      });
    };

    _this.getControls = function (_totalProgress, playState) {
      return React__default.createElement("div", {
        style: _this.containerStyle
      }, React__default.createElement("input", {
        ref: function ref(el) {
          return _this.slider = el;
        },
        type: "range",
        style: _this.sliderStyle,
        step: "0.001",
        onChange: function onChange(e) {
          return _this.onChange(e);
        },
        onMouseDown: function onMouseDown() {
          return _this.sliderTouched = true;
        },
        onMouseUp: function onMouseUp() {
          return _this.sliderTouched = false;
        }
      }), React__default.createElement("div", {
        style: _this.buttonContainerStyle
      }, React__default.createElement("div", null, React__default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(exports.PlayState.play);
        }
      }, "Play"), React__default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(exports.PlayState.reverse);
        }
      }, "Reverse"), React__default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(exports.PlayState.pause);
        }
      }, "Pause"), React__default.createElement("button", {
        type: "button",
        style: _this.buttonStyle,
        onClick: function onClick() {
          return _this.setPlayState(exports.PlayState.stop);
        }
      }, "Stop")), React__default.createElement("span", {
        style: _this.playStateStyle
      }, playState)));
    };

    return _this;
  }

  var _proto = Controls.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.consumers.length) {
      this.gsap = this.consumers[0];
      var gsap = this.gsap.getGSAP();

      if (gsap) {
        gsap.eventCallback('onUpdate', this.onUpdate);

        if (this.props.playState) {
          this.setPlayState(this.props.playState);
        } else {
          // get child initial state
          if (gsap.paused()) {
            this.setPlayState(exports.PlayState.pause);
          } else if (gsap.reversed()) {
            this.setPlayState(exports.PlayState.reverse);
          } else {
            this.setPlayState(exports.PlayState.play);
          }
        }

        var totalProgress = gsap.totalProgress();
        this.slider.value = totalProgress * 100;
      }
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.onUpdate();
  };

  _proto.render = function render() {
    var children = this.props.children;
    var _this$state = this.state,
        totalProgress = _this$state.totalProgress,
        playState = _this$state.playState,
        prevPlayState = _this$state.prevPlayState;

    if (this.gsap) {
      setPlayState(playState, prevPlayState, this.gsap.getGSAP());
    }

    return this.renderWithProvider(React__default.createElement("div", null, children, this.getControls(totalProgress, playState)));
  };

  return Controls;
}(Provider);

exports.Controls = Controls;
exports.Reveal = Reveal;
exports.ScrollTrigger = ScrollTrigger;
exports.SplitChars = SplitChars;
exports.SplitLetters = SplitLetters;
exports.SplitWords = SplitWords;
exports.Timeline = Timeline;
exports.Tween = Tween;
//# sourceMappingURL=react-gsap.cjs.development.js.map
